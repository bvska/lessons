package com.ifmo.jjd.lesson23;

public class StreamAPI {
    public static void main(String[] args) {
/*
             Stream API - набор методов для работы с данными, как с потоком.
             Позволяет представить различные наборы данных в виде потока,
             а далее: сортировать их, фильтровать, осуществлять поиск по различным критериям,
             кроме этого позволяет создавать новые потоки, создавать коллекции и мапы из потока данных и тд
         */
         /*
             Stream никогда НЕ ХРАНИТ ДАННЫЕ.
             Для сохранения данных из Stream нужно использовать специальные методы.
             Stream никогда НЕ ИЗМЕНЯЕТ ИСТОЧНИК (коллекцию, массив и тд), из которого он создан, все преобразования происходят только в потоках.
             В своей работе методы stream используют лямбда выражения.
         */

         /*
             Для работы с потоками данных необходимо:
             1. получить данные в виде потока - объект типа Stream
             2. выполнить промежуточные операции с потоком данных
             (промежуточные операции обрабатывают данные и возвращают Stream объект)
             3. выполнить терминальную (конечную) операцию
             (терминальная операция обрабатывает данные и завершает работу потока)
             Без терминальной операции промежуточные операции не начнут выполняться!!!
         */

        /*
             Например, получили объект stream, далее выполняем
             промежуточные операции
             stream.операция1() - вернет преобразованный объект stream
                   .операция2() - вернет преобразованный объект stream
                   .операция3()  - вернет преобразованный объект stream
                   .терминальнаяОперация(); // запускает промежуточные операции, данные обрабатываются, стрим закрывается
             основные терминальные операции: forEach / findFirst / findAny / xxxMatch / min / max / collect

         */

         /*
            Методы получения Stream объектов:
             * из коллекций collection.stream();
             * из массива Arrays.stream(arr);
             * из файла Files.lines(path_to_file);
             * из строки string.chars();
             * используя builder:
             * Stream.builder().add(obj1).add(obj2).add(objN).build();
             * Stream.of(1, 4, 7); любой набор данных
         */
         /*
         Распространенные промежуточные операции:
             * filter принимает на вход Predicate, возвращает поток (Stream) с теми объектами, которые удовлетворяют условию
             * map принимает на вход Function, возвращает новый поток (Stream), состоящий из обработанных функцией объектов
             исходного Stream
             * limit принимает на вход int, возвращает новый поток (Stream), состоящий из указанного количества первых объектов
             * skip принимает на вход int, убирает из потока указанной количество первых элементов,
             возвращает новый поток (Stream), состоящий из оставшихся элементов (или пустой Stream)
             * distinct возвращает поток (Stream), состоящий из уникальных объектов
             * sorted возвращает поток (Stream) отсортированных объектов, можно передать компаратор
             * peek принимает на вход Consumer, обрабатывает каждый элемент потока (Stream), возвращает новый поток (Stream)
         */
        /*
        Распространенные терминальные операции:
             * forEach принимает на вход Consumer, применяет переданный метод к каждому объекту потока (Stream),
             порядок Обработки при параллельном выполнении не гарантируется
             * anyMatch принимает на вход Predicate, возвращает true,  если хотя бы один элемент потока соответствует условию
             * allMatch принимает на вход Predicate, возвращает true,  если все элементы потока соответствуют условию
             * noneMatch принимает на вход Predicate, возвращает true,  если ни один элемент потока соответствует условию
             * findFirst возвращает первый элемент потока в Optional контейнере
             * findAny возвращает случайный элемент потока в Optional контейнере
             * min | max принимают на вход компаратор, возвращают минимальный / максимальный элемент потока в Optional контейнере
             * collect принимает на вход Collector, возвращает коллекцию или мапу
         */
    }
}
